###아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용해라 

---
**정적메서드와 정적필드** 
메서드 선언부에 static 키워드가 선언된 메소드를 정적 메서드라고 한다. static으로 선언되었으므로 main() 메서드가 실행되기 전에 method 메모리 영역에 생성되어서 사용준비가 완료 된다. 정적 필드는 모든 인스턴스가 공유하는 멤버이다.

**이따금 단순히 정적 메서드와 정적 필드만을 담은 클래스를 만들고 싶을 때가 있다!**
- java.lang.Math나 java.util.Collections처럼 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드(팩터리)를 모아놓을 수 있다.
  + 자바 8 부터 이런 메서드를 인터페이스에 넣을 수 있다. 
- final 클래스와 관련한 메서드들을 모아놓을 때도 사용한다. 
  + final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능하기 때문이다. 


**이러한 경우 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 것이 아니기 때문에 인스턴스화를 막아주는 것이 좋다.** 
- 추상클래스로 만드는 것으로 인스턴스화를 막을 수 없다.(상속해서 사용할 수 있기 때문이다.) 
- 컴파일러가 기본 생성자를 만드는 경우는 오직 명시된 생성자가 없을 때뿐이니 **private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.**
- 명시적 생성자가 private라서 바깥에서 접근하기 어렵다. 또한 상속을 불가능하게 만든다.(private로 선언했기 때문에 하위클래스가 상위클래스의 생성자에 접근할 수 없다.)
- 클래스 내부에서 실수로 생성자를 호출하지 않도록 AssertionError를 던져준다. 

```
// 코드 4-1 인스턴스를 만들 수 없는 유틸리티 클래스 
    public class UtilityClass {
        // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용).
        private UtilityClass() {
            throw new AssertionError();
        }

        public static String hello() {
            return "hello";
        }
    }

    public static void main(String[] args) {
            String hello = UtilityClass.hello()
    }

```
이렇게 만든 유틸리티 클래스는 외부에서 사용시 정적 메소드만 사용한다.


### 아이템 8. finalizer와 cleaner 사용을 피해라 

--- 
Java에서는 두가지 객체 소멸자를 제공한다. finalizer와 cleaner이다. 두 경우 모두 기본적으로 사용하지 말아야 한다. 

**finalizer란?**
Object 클래스에서 제공하는 finalize() Method이며 자바 9버전 이후 Deprecated 되었다.   

**Cleaner란?**
Cleaner란 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고 일반적으로 불필요하다. 


#### 사용하지 말아야 하는 이유 
**(1) 제때 실행되어야 하는 작업을 절대 할 수 없다.**   

finalizer와 Cleaner는 즉시 수행된다는 보장이 없다. 예컨대 파일 닫기를 finalizer나 cleaner에게 맡기면 시스템이 동시에 열 수 있는 파일 개수에 한계가 있기에 중대한 오류를 일으킬 수 있다. 시스템이 finalize나 cleaner 실행을 게을리해서 파일을 계속 열어 둔다면 새로운 파일을 열지 못해 프로그램이 실패 할 수 있다.   

**(2) 수행 여부 또한 보장하지 않는다.**    

종료 작업을 전혀 수행하지 못한 채 중단될 수 있다. 
finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다. 잡지 못한 예외 때문에 해당 객체는 자칫 마무리가 덜 된 상태로 남을 수 도 있다. 보통의 경우, 잡지 못한 예외가 스레드를 중단시키고 스택 추적 내역을 출력하겠지만, finalizer는 경고조차 출력하지 않는다. 

**(3) 심각한 성능 문제도 동반한다.**   

가비지 컬렉터의 효율을 떨어트리고 안전망 설치의 대가로 성능이 5배 정도 느려진다. 

**(4) 보안문제를 일으킨다.**  

생성자나 직렬화 과정에서 예외가 발생하면 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있다. finalizer에서 정적필드에 자기 자신을 할당하여 GC의 수거를 막을 수 있다.   
final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무일도 하지 않는 finalize 메서드를 만들고 final로 선언해야 한다. 

### 정상적으로 자원을 종료하려면?   
파일이나 스레드 등 종료해야 할 자원을 담고 있는 객체의 클래스에서 **AutoCloseable을 구현해주고, 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출해주는 방식이 있다.**
close 메서드에서 이 객체는 더이상 유효하지 않음을 필드에 기록하고, 다른 메서드는 필드를 검사해서 객체가 닫힌 후에 불렸다면 IllegalStateException을 던지면 된다. 

### Finalizer, Cleaner의 적절한 사용법 
**(1) 자원의 소유자가 close 메서드를 호출하지 않은 것에 대한 안전한 대비망**   

즉시 호출된다고 보장은 없지만 자원 회수를 늦게라도 해주므로 안전망 역할이다. 예를 들어, FileInputStream, FileOutputStream, ThreadPoolExecutor가 존재한다.   

**(2) 네이티브 피어와 연결된 객체에서의 사용**   

네이티브 피어란 일반 자바 객체가 아닌 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다. 
네이티브 피어는 자바 객체가 아니니 가비지 컬렉터는 그 존재를 알지 못한다. 따라서 자바피어를 회수 할 때 네이티브 피어까지 회수 하지 못하니 cleaner나 finalizer가 처리할 수 있다. 
